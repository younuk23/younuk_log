---
title: Javascript 톺아보기 6.프로토타입
date: "2021-09-26T21:33:45.007Z"
description: "자바스크립트에서 객체간의 상속을 구현한 방법과 일반적인 Classical inheritance와의 차이점을 알아보자"
---

자바스크립트를 공부하다보면 프로토타입이라는 단어를 필수적으로 접하게 된다.
그리고 "클래스는 프로토타입의 문법적 설탕이다." 라는
문장까지 접하게 되면서 언어 학습에 있어서 1차적인 고비를 겪게 되는 것이
일반적인 자바스크립트 프로그래머들이 겪는 과정일 것이다.

그래서 이번 포스팅에서는 프로토타입이 어떤 목적을 가지고 탄생한 개념인지 알아보고,
자바스크립트에서 프로토타입이 동작하는 방식을 알아본 뒤 최종적으로 프로토타입과 클래스에 대해서 비교해보는 내용을 다루고자 한다.
먼저, 프로토타입이 무엇인지 부터 알아보자.

## 프로토타입이란?

프로토타입이란 객체간의 상속을 구현하는 방법 중의 하나이다.
여기서 객체간의 상속이라는 단어는 프로그래밍 패러다임 중 하나인 객체지향 프로그래밍에서
활용하는 개념이다.

프로토타입에 대해서 이해하기 위해서 먼저 객체간의 상속이 왜 필요한지, 그리고 이를 사용하는
객체지향 프로그래밍은 어떤 것인지에 대한 기반지식이 필요하다.

### 프로그래밍 패러다임과 객체지향 프로그래밍

프로그래밍 패러다임은 프로그래머들이 프로그래밍을 할 때 관점을 갖게 해주고, 결정하는 역할을 한다.
이런 프로그래밍 패러다임은 여러가지가 있지만 현대에 널리 퍼져있는 패러다임들에는 객체지향 프로그래밍, 함수형 프로그래밍이 두가지가 대표적이다.

이 중에서 객체지향 프로그래밍은 프로그램의 모든 동작을 객체간의 소통으로 정의한다.
이러한 객체지향 프로그래밍의 시작은 현실세계 또는 추상적인 개념들을 속성과 동작으로 정의해서 그걸 프로그래밍에 접목하고자 하는 생각에서 출발되었다.

객체라는 것은 우리가 알고있는 개념들을 속성과 동작의 모음으로 생각하고 구분한것이다.
예를 들어, 우리가 강아지를 생각할 때 `종`은 개과이며, `달리기, 짖기, 밥먹기` 등의 동작을 할 수 있는 것이라고 추상화 할 수 있다.
이렇게 강아지란 하나의 개념을 `종`이라는 속성과 `달리기, 짖기, 밥먹기`로 정의한 것이 바로 객체이다.
객체지향 프로그래밍은 프로그램들을 이런 객체들의 관계를 통해서 구성하고자 하는 패러다임이다.

객체를 좀 더 프로그래밍적인 관점에서 정의하자면 객체란 스스로가 가지고 있는 속성(데이터)과 그 속성을 조작할 수 있는 동작(메서드)로 구성된 복합적인 자료구조이다.
객체지향 프로그래밍에서 개발자는 원하는 형태의 구조를 객체로 만들어서 객체들의 조합으로 프로그램을 구성한다.

### 객체지향의 3가지 조건

이러한 객체지향 프로그래밍을 하기 위해서는 객체는 아래와 같은 3가지의 특징을 가지고 있어야 한다.

1. 상속
2. 캡슐화
3. 다형성

이 중에서 먼저 캡슐화(encapsulation)는 객체를 구조로 생각했을 때 수반되는 개념으로서 내부의 상태와 동작을
하나의 범위에 묶은 형태가 객체이기 때문에 상태와 동작이 객체안에 묶여있다는 의미이다.

그리고 다형성은 하나의 객체로부터 파생된 다른 객체들이 각기 다른 동작들을 할 수 있다는 의미이다.
예를들어, `Animal`이란 객체로부터 `Lion, Wolf, Cow`등이 파생된다고 했을 때 `Lion, Wolf, Cow`는 모두 `Aniaml`의 특징인
`짖다`라는 동작을 가지지만, `Lion`의 짖음과 `Wolf`의 짖음, `Cow`의 짖음은 각기 다른 소리를 낼 것이다.

위의 예시에서 **하나의 객체로부터 파생된다** 라는 말이 있다. 이것이 바로 상속을 나타내는 말이다.
상속이란 한 객체가 가진 특성을 그대로 가진 새로운 객체를 만들어내는 행위이다.
그래서 Animal 객체가 가진 특성을 그대로 가진채 조금 더 구체화된 Lion, Wolf, Cow등의 새로운 객체를 만들어낼 수 있는 것이다.

상속을 통해서 개발자들은 코드를 재사용할 수 있게 되었다. 만약 Animal이란 객체가 가진 특성을 코드로 작성하고
그걸 Lion, Wolf, Cow에 모두 동일하게 다시 작성해야 한다면 중복이 발생하고 이는 곧 개발단계의 불편함, 그리고 유지보수가 용이하지 않은 코드를 양산할 것이다.
하지만 상속을 통해서 코드를 다시 작성하지 않고도 다른 객체가 가진 특성을 상속된 객체에서 그대로 가져올 수 있게 되었다.

즉, 다형성은 상속이 가능해야 구현될 수 있는 특징이다. 다른 객체를 상속함과 동시에 내부 동작을 각기 객체에 맞게 수정할 수 있다는 것이 다형성이란 특징인 것이다.
따라서 상속이 객체지향에서 굉장히 근간이 되는 개념임을 알 수 있다.

### 프로토타입 이란?

대부분의 객체지향 패러다임을 지원하는 언어들(Java, Python 등)은 객체의 구조를 정의하기 위해서 Class란 개념을 도입했다.
Class란 실제 현존하는 객체는 아니지만 객체의 구조에 대한 일종의 명세서라고 할 수 있다.
Class 기반 언어에서는 이 명세서를 이용해서 실제 객체를 만들 수 있다.
또한, Class 기반 언어에서는 이 Class끼리의 관계를 설정하여서 하나의 Class가 다른 Class를 상속하도록 만들 수 있는 기능을 제공한다.

하지만 프로토타입 기반언어에서는 객체간의 상속을 프로토타입이란 개념을 통해서 구현한다.
프로토타입은 Self라는 프로그래밍언어에서 처음으로 도입 된 개념으로서 한 객체가 다른 객체의 프로토타입 즉, 원형이 되는 개념이다.
그래서 부모객체(원형)으로 부터 파생된 자식 객체들이 원형객체에 있는 속성들도 사용할 수 있게 하면서 객체간의 상속을 구현한다.

프로토타입 언어에서는 객체간의 관계가 Class라는 명세서끼리의 관계가 아니라 객체와 객체가 바로 직접적으로 관계가 맺어진다는 특징을 가진다.
그리고 자바스크립트는 함수형 프로그래밍, 객체지향 프로그래밍을 모두 지원하는 멀티 패러다임 언어이면서 객체간의 상속에서는 프로토타입의 개념을 차용해서 사용하고 있다.

## 프로토타입의 원리

프로토타입의 원리는 간단하다. 모든 객체는 자신의 프로토타입 객체를 가지고 있으며 프로토타입 객체의 프로퍼티들을 사용할 수 있다.
그리고 이 과정은 프로토타입 링크를 통해서 구현된다.

### 프로토타입 링크

프로토타입 링크란 객체들이 모두 프로토타입을 가지고 있으며 이 프로토타입이 연결되어있는 형태를 말한다.
자바스크립트에서 모든 객체들은 `[[proto]]`라는 내부 슬롯을 가지고 있으며 이 내부슬롯에는 자기의 프로토타입 객체에 대한 레퍼런스가 저장되어 있다.

그리고 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 적절한 프로퍼티가 없다면 프로토타입 객체로 연결되어서 프로토타입 객체에서 해당하는 프로퍼티가 있는지 찾아본다.
그리고 프로토타입객체 또한 객체이므로 자신의 프로토타입을 가지고있다 따라서 프로토타입 객체에도 프로퍼티가 없다면 프로토타입의 프로토타입을 또 찾아간다.
이러한 동작을 프로토타입 링크라고 하며, 이 링크는 원하는 프로퍼티를 찾거나, 객체의 프로토타입이 null을 가리킬 때 까지 이어진다.

예를 들어서 Person이란 객체가 있고 거기서 Student라는 객체가 파생되었다고 했을 때 Student의 프로토타입은 Person이다.
만약 Student에서 `eat`이란 프로퍼티에 접근하려 했을 때 Student가 `eat` 프로퍼티를 가지고 있지 않다면 프로토타입 링크를 통해서 Person객체에 `eat` 프로퍼티가 있는지 검색한다.
그 뒤에 Person 객체에서 `eat` 프로퍼티를 찾았다면 그 프로퍼티를 사용하는 방식이다.

이 방식을 통해서 객체의 모든 프로퍼티들을 중복으로 작성하지 않고도 객체간의 상속을 구현할 수 있게 되었다.

### 생성자 함수와 프로토타입

프로토타입이라는 하나의 큰 개념에서도 프로토타입을 통한 상속을 어떻게 구현하느냐에 따라서 `Prototypal pattern`과 `Constructor pattern`으로 구분되게 된다.
Prototypal pattern은 프로토타입의 개념 그대로 객체를 다른 객체로부터 파생해서 생성하는 방식이고 Constructor pattern은 생성자 함수를 통해서 객체를 생성하고 그 내부적으로
프로토타입의 개념이 숨겨져 있는 방식이다.

Prototypal pattern이 프로토타입의 개념인 객체와 객체간 프로토타입 관계가 맺어진다라는 측면을 직관적으로 표현하기 적합하지만 자바스크립트의 창시자 브랜든 아이크는
자바스크립트를 만들 당시 자바와 유사하게 보여야 한다는 요구사항을 충족하기 위해서 내부적으로는 Prototype inheritance지만 겉으로는 Classical inheritance처럼 보이도록
Constructor pattern을 사용해서 프로토타입을 구현하게 되었다.

Constructor pattern은 Classical inheritance를 구현한 다른 언어들이 Class가 있고 그 Class 내부에 constructor 함수가 존재해서 `new` 키워드를 이용해서 해당 Class의
constructor 함수를 호출해서 새로운 객체를 만드는 방식을 흉내낸 방식이다.

자바스크립트는 constructor pattern을 사용하면서 자바와 유사하게 보이는 객체 생성 문법을 얻었지만, 함수를 일반함수로서 호출했을 때와 생성자 함수로서 호출했을 때의 동작이 확연하게 다르게 되었고
프로토타입의 장점인 객체와 객체간의 직접적인 연결동작이 감춰지게 되면서 많은 자바스크립트 개발자에게 혼란을 일으키게 되었고 이는 더글라스 크락포드를 비롯한 많은 자바스크립트 개발자들이 잘못된 선택이라고
주장하는 결과를 낳게 되었다.

### 프로토타입 객체

서두에서 모든 자바스크립트의 객체는 내부에 `[[proto]]`라는 내부슬롯을 가지고 여기에는 프로토타입 객체에 대한 레퍼런스가 저장된다고 했다.
일반적으로 자바스크립트의 내부슬롯과 내부메서드등에 대해서는 접근할 방법이 없지만 `[[proto]]` 내부슬롯에 한해서는 간접적으로 접근할 방법이 허용되게 되어있다.
객체에서 `__proto__` 프로퍼티에 접근하면 `[[proto]]` 내부 슬롯에 저장된 프로토타입 객체에 접근할 수 있게 된다.
`__proto` 프로퍼티는 원래 ECMA-script 정식 명세에 없었지만 일부 브라우저가 지원하기 시작했고 광범위하게 사용되기 시작하자 결국 ECMA-script 정식 명세에서도 `__proto__` 프로퍼티에 대한 정식 명세가 포함되게 되었다.

`__proto__`는 데이터 프로퍼티가 아니라 `get, set` 메서드로 이루어진 접근자 프로퍼티이다.
`__proto__`에 접근해서 값을 읽으려고 하면 `get` 메서드가 호출되어서 리턴값이 출력되고, 값을 새로운 값으로 설정하려고 하면 `set` 메서드가 호출되어서 프로퍼티의 값을 바꿔주는 형식이다.
그 이유는 만약 프로토타입 링크가 단방향이 아니라 상호참조로 된다면 특정 프로퍼티를 접근하고자 했을 때 무한루프에 빠질 수 있기 때문에 상호참조형식으로 설정하는 것을 방지하기 위해서이다.
또한, `Object 생성자 함수`에는 `getPrototypeOf, setPrototypeOf` 라는 정적 메서드가 있는데 이를 통해서도 특정 객체의 프로토타입 객체를 읽고 쓸수 있다.

지금까지 프로토타입이 어떻게 동작하고 프로토타입 객체에 어떻게 접근할 수 있는지 알아봤는데 그렇다면 객체의 프로토타입 객체는 어떻게 정해지는지 알아보자.

### 프로토타입의 결정 방식

1. 객체 리터럴

객체를 생성할 때 가장 많이 사용하는 방식은 객체 리터럴을 이용해서 생성하는 방식일 것이다.
`const obj = {};` 이렇게 객체 리터럴을 사용해서 객체를 생성하면 생성된 객체의 포로토타입 객체는 `Object.prototype`을 가리키게 된다.

```javascript
const obj = {}

obj.__proto__ === Object.prototype // true
```

2. Constructor function

객체를 생성하는 두번째 방법은 생성자 함수를 이용하는 방식이며 constructor pattern 이라고도 불린다.

자바스크립트에서 arrow function과 메서드 단축구문을 통해서 생성된 함수를 제외한 모든 함수는 constructor function으로서 사용될 수 있다.

constructor function은 new 키워드와 함께 호출되면 내부적으로 this에 새롭게 생성될 객체를 바인딩하고 this 객체에 여러 프로퍼티들을 정의 한 뒤 최종적으로 this를 리턴한다.
이를 통해서 새로운 객체를 만들어낼 수 있다.

```javascript
function Circle(radius) {
  this.radius = radius
}

const circle = new Circle(10)

console.log(circle)
// {
//  radius: 10,
//  __proto__: { constructor: ƒ Circle() }
// }
```

생성자 함수를 통해서 생성된 객체들의 프로토타입 객체는 `[생성자함수].prototype`객체이다. 위의 예시코드에서
Circle 생성자함수로 만든 circle객체의 `__proto__` 프로퍼티에 `Circle.prototype`이 할당되어있는 것을 확인할 수 있다.

`[생성자함수].prototype`객체의 내부를 들여다보면 `constructor` 프로퍼티에 생성자 함수가 할당되어있는 객체를 확인할 수 있다.
이 객체에 특정 프로퍼티들을 추가하게 되면 이제 생성자함수를 통해서 만들어진 객체들은 모두 그 프로퍼티에 접근할 수 있게 되는 것이다.

```javascript
function Circle(radius) {
  this.radius = radius
}

Circle.prototype.getDiameter = () => this.radius * 2

const circle = new Circle(10)
circle.getDiameter() // 20
```

이 `[생성자함수].prototype` 객체는 constructor로서 사용될 수 있는 함수가 평가되어 생성될 때 동시에 생성되며 초기에는 constructor 프로퍼티에 생성자함수가
할당되어있는 형태로 생성된다.

이러한 동작을 통해서 우리가 Object 생성자 함수를 통해서 만든 객체들이 Object.prototype에 있는 `__proto__, hasOwnProperty` 등의 여러 메소드들을 활용할 수 있게 된 것이다.

그리고 `[생성자함수].prototype` 객체의 프로토타입은`Object.prototype`이므로 생성자함수를 통해서 만들어낸 다른 객체들 또한 `Object.prototype`객체의 메소드들을 활용할 수 있게 된다.

```javascript
function Circle(radius) {
  this.radius = radius
}

const circle = new Circle(10)
console.log(circle) // {radius:10, __proto__:Circle.prototype}
console.log(Circle.prototype.__proto__) // Object.prototype
circle.hasOwnProperty("radius") // true
```

3. Object.create를 이용한 직접상속

Object.create를 이용한 객체 상속은 직접상속이라고도 불리며 prototypal pattern의 객체 상속을 구현한 것이라고 볼 수 있다.
Object.create 함수를 이용해서 객체를 생성하면 새롭게 생성된 객체의 프로토타입 객체는 함수의 인자로 전달된 객체로 설정된다.

```javascript
const circleProto = {
  getDiameter() {
    return this.radius * 2
  },
}

const circle = Object.create(circleProto)
circle.radius = 10
circle.getDiameter() // 20
console.log(circle.__proto__ === circleProto) // true
```

이를 통해서 객체간의 직접적인 상속구조를 만들어낼 수 있게 되었다.
constructor pattern을 이용하면 객체간의 상속구조가 코드상에서 바로 눈앞에 드러나지 않기 때문에 알아보기 힘든 경향이 있지만 직접상속을 이용하면
객체가 어떤 객체를 상속받는지 명확히 눈에 보이기 때문에 구조를 파악하기 용이하다.

그리고 객체 안에 팩토리 함수를 프로퍼티로 만들어둠으로서 객체를 상속받는 새로운 객체를 만들어 내는 패턴을 만들수도 있다.

```javascript
const circle = {
  create(radius) {
    const newCircle = { radius }
    newCircle.__proto__ = circle
    return newCircle
  },
  getDiameter() {
    return this.radius * 2
  },
}

const cc = circle.create(10)

cc.getDiameter() // 20
cc.__proto__ === circle // true
```

또한, 일반적으로 생성자 함수를 이용한 객체 생성이든지, 객체 리터럴을 이용한 상속이던지 프로토타입의 마지막에는 `Object.prototype` 객체가 있기 마련인데 직접상속을 이용하면 null을 상속받는 객체를 만듦으로서
자신이 프로토타입 링크의 최상단에 위치한 객체를 만들수도 있다.

```javascript
const circleProto = Object.create(null)
circleProto.getDiameter = () => this.radius * 2

const circle = Object.create(circleProto)

circle.radius = 10
circle.getDiameter() // 20

circle.hasOwnProperty(10) // TypeError: circle.hasOwnProperty is not a function
Object.getPrototypeOf(circleProto) // null
```

위 예시코드에서 `hasOwnProperty`라는 함수는 `Object.prototype`에 있는 메서드인데 circleProto는 `null`을 직접상속한 객체로서 자신의 프로토타입으로 `Object.prototype`가 아닌 `null`을 갖는다.
프르토타입 링크는 프로토타입이 null을 가르키는 순간 종료되므로 `circle`에서는 `Object.prototype.hasOwnProperty` 메서드에 접근할 수 없게되었다.

## 프로토타입 기반 상속 vs 클래스 기반 상속

지금까지 프로토타입을 기반으로 하는 객체 상속이 어떻게 이루어지는지 알아보았다.
여기까지 읽었다면 그래서 Class base inheritance와 비교해서 Prototype base inheritance가 가지는 장점이 무엇이고 왜 자바스크립트가 프로토타입 기반 상속을 선택했는지 궁금즘이 생겼을 수 있다.

### 프로토타입과 클래스 기반 상속의 근본적인 차이점

프로토타입 기반 상속과 클래스 기반 상속의 근본적인 차이점이라면 클래스 기반 상속에서는 객체 외에 객체에 대한 명세서 역할을 하는 Class라는 개념이 존재하고
이에 수반해서 Interface, Abstract Class등의 추가적인 개념또한 존재하지만 프로토타입 기반 상속에서는 객채라는 개념만 존재하고 이 객체간의 관계설정을 통해서 상속을 구현한다는 차이점이 있다.
프로토타입과 클래스의 장단점은 사실 모두 위 특징에 기반해서 결정된다고 볼 수 있다.

지금부터 기술할 프로토타입의 장단점은 모두 클래스와 비교했을 때의 장단점이며, 여기서 말하는 클래스는 자바스크립트의 프로토타입을 이용해서 구현된 Class 문법이 아닌 일반적인 Class 기반 객체지향 언어에서의 Class를 의미한다.

### 프로토타입의 장점

프로토타입의 장점은 크게 `Simple, Less Redundant, Dynamic` 3가지로 말할 수 있다.

1. Simple

프로토타입 기반 상속에서는 객체를 만들고, 객체간의 관계를 규정하기 위해서 Class등의 부가적인 문법이 필요하지 않다.
이러한 장점으로 인해서 프로토타입을 사용할 때는 간단하게 객체를 만들고 객체간의 상속관계를 규정할 수 있다.

```javascript
const animal = {
  bark(){
    console.log("Barking...")
  }
  walk(){
    console.log("뚜벅 뚜벅")
  }
};

const dog = Object.create(animal);

dog.bark = () => console.log("멍멍"); // polymorphism implement

dog.bark(); // 멍멍
dog.walk(); // 뚜벅뚜벅
```

프로토타입 상속을 이용하면 위와 같이 간단하게 상속된 객체를 만들고 다형성을 구현할 수 있지만 Class를 통해서 동일한 동작을 하려면 Class를 선언하고 Class로부터 인스턴스를 만드는 등의 과정을 거쳐야 한다.

```javascript
class Animal {
  bark() {
    console.log("Barking...")
  }

  walk() {
    console.log("뚜벅뚜벅")
  }
}

class Dog extends Animal {
  bark() {
    console.log("멍멍")
  }
}

const dog = new Dog()

dog.bark() // 멍멍
dog.walk() // 뚜벅뚜벅
```

Class를 이용한 코드들에 익숙한 프로그래머들이 많기에 위의 Class 문법이 좀 더 친숙하게 느껴질 수 있겠지만, 객체를 만들고 상속관계를 규정하기까지 절대적으로 필요한 코드의 양과 복잡도는 확실히 Class 기반의 구현이 더 높은 것을 알 수 있다.

2. Less Redundant

위의 Simple이라는 특징과 연관되는 장점인데 Prototype 기반 상속은 Less Redundant하다.
Class는 사실상 일종의 객체의 meta-data(데이터를 설명하기 위한 데이터)의 역할을 하고 있다.
이러한 meta-data는 객체의 구조에 대한 설명, 그리고 일종의 타입 선언 처럼 역할을 하기에 좀 더 객체를 파악하는데 도움을 줄 순 있겠지만,
객체를 만드는데 필수 불가결한 요소는 아니라고 볼 수 있다. 따라서 이러한 객체에 대한 meta data의 역할을 하는 Class를 불필요한 요소라고 판단한다면 프로토타입은 클래스에 비해서 Less Redundant하다고 볼 수 있다.

3. Dynamic

마지막으로 엄밀히 말하자면 프로토타입의 자체의 특징이라고 볼 순 없지만 자바스크립트는 동적타입언어이고 프로토타입 기반 언어에서는 객체와 객체끼리 직접적으로 상속관계를 가지기 때문에
어떤 객체의 프로토타입 객체 또한 동적으로 수정할 수 있다.
이는 한번 선언된 Class는 런타임에서 수정할 수 없다는 점과는 대비해서 동적인 프로그래밍을 가능하게 한다.
이러한 장점은 동적 타입 언어인 자바스크립트의 특성과 잘 부합해서 런타임에서 좀 더 유연한 프로그래밍을 가능하게 한다는 장점을 가진다.

```javascript
const animal = {
  bark() {
    console.log("Barking...")
  },

  walk() {
    console.log("뚜벅 뚜벅")
  },
}
const dog = Object.create(animal)

animal.eat = () => {
  console.log("Eating...")
}

dog.eat() // Eating...
```

위의 코드에서는 animal 객체를 선언한 뒤 animal 객체를 상속받은 dog 객체를 만들었다. 그리고 그 뒤에 동적으로 animal에 eat이란 메소드를 추가하고 그걸 dog 객체에서도 바로 사용할 수 있는 모습을 확인할 수 있다.
이처럼 프로토타입 기반언어는 객체와 객체가 직접적으로 연결되고 자바스크립트는 동적 타입 언어라서 객체를 런타임에 수정할 수 있다는 특성을 통해서 런타임에서 동적으로 부모객체에 메소드를 추가하고
자식객체가 추가된 메소드를 활용할 수 있다는 다이나믹한 특징을 가진다.

### 프로토타입의 단점

하지만 위의 장점들은 때에 따라서 단점이 될 수도 있다.
예를들어 프로토타입 객체를 동적으로 수정이 가능하다는 장점은 때에 따라서 런타임에서 객체를 수정하면서 버그를 유발하기 쉽게 된다는 이면을 가지고 있다.

그리고 Class가 객체의 meta-data적인 역할을 하는데 이는 필수적인 요소는 아니지만 이러한 meta-data를 통해서 객체의 구조에 대해서 더 많은 정보를 얻을 수 있는 것은 사실이다.
프로토타입 기반에서는 이러한 meta-data를 제공하지 않는다라는 점이 때에 따라서는 단점으로 다가올 수도 있다.

## 결론

위에서 알아봤듯이 프로토타입은 `Simple, Less Redundant, Dynamic` 이라는 장점을 가질 수 있지만 이는 항상 장점으로만 작용하는 것이 아니라 그에 상응하는 trade-off가 있다.

프로그래밍에는 여러가지 패러다임, 구현방법이 존재할 수 있다. 이 포스팅에 나온 프로그래밍 패러다임으로만 해도 함수형 프로그래밍, 객체지향 프로그래밍이 있고 그 중 객체지향 프로그래밍에서 상속을 구현하는 두가지 방법으로
프로토타입 기반 상속, 클래스 기반 상속 두가지 케이스를 알아보고 프로토타입을 기준으로 해서 클래스와 비교했을 때 장단점을 알아봤었다.

소프트웨어 개발은 실시간으로 현실세계에서 발생하는 여러가지 문제를 해결하는 행위이다.
그러므로 개발에서는 모든 상황에서 통용되는 절대적인 답, 절대원칙은 존재할 수 없다. 단지 우리가 해결해야 되는 문제와 상황에 맞는 제일 최적의 솔루션만이 있는 것이다.
따라서 우리가 개발을 할 때 여러 패러다임, 방법론을 접하면서 어떤 방법론에 매몰되거나 전가의 보도처럼 여기는 것 보다는 상황에 맞게 적절한 솔루션을 선택할 수 있는 능력이 필요하다.

자바스크립트는 처음에 브라우저에서 사용할 수 있는 간단한 스크립트 언어를 목적으로 만들어졌기에
객체간의 상속을 구현할 때 간단하고, 불필요한 부분이 적고,
자바스크립트의 동적 타입 시스템에 잘 부합되는 프로토타입을 선택하였고
이는 자바스크립트의 특징이 되었다.
그 후에 자바스크립트가 점점 더 널리 쓰이고 발전하면서 다양한 요구사항을 받아들이는 과정에서 Class 문법에 대한 요구가 늘어나면서
프로토타입을 기반으로해서 Class의 동작 또한 구현해서 제공을 해주게 되었다.

이처럼 상황과 요구조건에 맞춰서 적절한 기술을 선택할 수 있는 개발자가 좋은 개발자이며
그러기 위해서는 각 패러다임, 방법론에 담긴 철학과 특징 장단점을 잘 이해해야 한다고 할 수 있다.

### 참고자료

[모던 자바스크립트 Deep dive](https://books.google.co.kr/books?id=g4fazQEACAAJ&dq=%EB%AA%A8%EB%8D%98+%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+deep+dive&hl=ko&sa=X&redir_esc=y)  
[Stackoverflow](https://stackoverflow.com/questions/2800964/benefits-of-prototypal-inheritance-over-classical?noredirect=1&lq=1)  
[Stackoverflow](https://stackoverflow.com/questions/816071/prototype-based-vs-class-based-inheritance)  
[Why Protypal Inheritance Matters](http://aaditmshah.github.io/why-prototypal-inheritance-matters/)
