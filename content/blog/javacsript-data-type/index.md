---
title: Javascript 톺아보기 1. 데이터 타입
date: "2021-07-30T06:17:23.424Z"
description: "프로그래밍 언어에서 데이터 타입은 무엇이고, 왜 중요한지, 그리고 자바스크립트의 데이터 타입은 어떻게 동작하는지 알아보자"
---

자바스크립트로 개발을 계속 해오고 있고, 자바스크립트를 어느정도 안다고 생각하고 있었다.
하지만 막상 누군가 "자바스크립트를 아세요?" 라고 물어보면 자신있게 안다고 대답할 수 있을까란 의문이 들었다.

그리고 과분하게도 주니어개발자들에게 멘토링을 하고 있는 포지션에서 막연하게만 알고있던 지식들을 가다듬으며
나만의 정제된 언어로 표현할 수 있으면 더 좋은 멘토링을 할 수 있겠다란 생각이 들었다.

그래서 자바스크립트를 톺아보는 시간을 가지고자 한다.  
그 시작으로 자바스크립트의 데이터 타입에 대해서 알아보자

## 데이터 타입

데이터 타입이란 무엇일까?  
그전에, 프로그래밍이란 무엇일까?

프로그래밍의 정의는 다음과 같다.

> 프로그래밍은 하나 이상의 관련된 추상 알고리즘을 특정한 프로그래밍 언어를 이용해 구체적인 컴퓨터 프로그램으로 구현하는 기술을 말한다.
> [^1]

쉽게 표현하자면 우리가 원하는 동작을 컴퓨터가 알아들을 수 있는 언어를 통해서 컴퓨터에게 명령하는 기술이다.

우리가 실제로 원하는 일들을 컴퓨터에게 명령하는 과정에서 필연적으로 거치게 되는 과정이 있는데 바로 값을 **저장**하고, **연산**하는 과정이다.

우리가 "Hello world"라는 인사말을 건네는 과정을 생각해보자. 우리는 저 인사말을 하기 위해서 우리 머릿속에 **저장**되어 있는
"Hello"라는 단어와 "world"라는 단어를 꺼내오고 그 두 단어를 합치는 **연산**을 통해서 "Hello world"라는 인사말을 만들어낸다.

"Hello world"뿐만 아니라 더 다양하고 복잡한 동작을 하기 위해서는 더 많은 단어들을 저장하고 조합할 수 있어야 한다.
사람이라면 다들 영어시험을 앞두고 하나라도 많은 단어를 외우려고 갖가지 암기법을 시도해본 경험이 있을 것이다.
일반적인 사람들과 마찬가지로 컴퓨터도 한정된 공간에 최대한 많은 정보를 저장하기 위한 방법을 고민하면서 데이터 타입이 탄생하게 되었다.

먼저, 컴퓨터는 어떻게 데이터를 저장하는지에 대해서 훑어보자.  
컴퓨터는 데이터를 메모리라는 물리적인 공간에 저장한다. 컴퓨터가 이해할 수 있는 언어는 0과 1뿐이다.
그래서 메모리의 최소단위는 0또는 1을 포현할 수 있는 **1bit**라는 단위로 표현한다.
0 또는 1로는 표현할 수 있는 범위가 한정적이기에 8bit를 모아서 1byte라는 단위를 만들었다.
1byte는 8bit로서 2^8인 256개의 값을 표현할 수 있는 단위다.

| units    | size            |
| :------- | :-------------- |
| Bit      | binary(0 or 1)  |
| Byte     | 8Bit            |
| Kilobyte | 1024 Bytes      |
| Megabyte | 1,024 Kilobytes |
| Gigabyte | 1,024 Megabyte  |

그러면 데이터 타입은 어떻게 많은 정보를 효울적으로 저장할 수 있게 만드는 것일까?
데이터를 분류해두면 데이터 타입에 따라서 메모리에서 어느정도의 공간을 차지할 지 예측이 가능해지며,
과도하게 많은 공간을 비워 둘 필요 없이 필요한 만큼만 메모리를 할당할 수 있게 된다.

예를 들어, 당신이 식당주인이라고 가정하자.  
어느 손님이 "오늘 저녁에 단체로 갈테니까 준비주세요"라고만 말한다면
당신은 몇명이 올 줄 몰라서 단체손님을 맞기 위해서 식당 전체를 비워둬야 되는 비효울적인 상황이 발생할 수도 있다.  
하지만, "오늘 저녁에 30명 갈테니까 준비해주세요"라고 말한다면 당신은 5인 테이블 6개만 비워두고
나머지 공간은 다른 손님을 받는데 효율적으로 활용할 수 있다.

위의 예시를 다시 컴퓨터적 관점으로 생각해보면, 각 데이터 타입별로 차지하게 될 메모리를 미리 정해두면 공간을 효율적으로 사용할 수 있게 된다.
실제로 자바스크립트는 숫자에는 8byte의 메모리를 할당하고, 문자열은 길이가 정해져있지 않기에
하나하나의 문자단위로 나눠서 문자당 2byte를 할당하고 있다.

컴퓨터는 값을 읽어오기 위해서 값이 저장된 메모리의 주소를 통해서 값에 접근한다.  
그렇다면 숫자타입을 읽으려면 8byte만큼의 주소값을 모두 기억하고 있어야 하는걸까?

숫자 값을 읽기 위해서 8byte만큼의 주소값을 모두 기억하고 있는 것은 굉장히 비효율적이다.
그래서, 컴퓨터는 첫번째 주소값만 기억하고 있다가 값을 읽어야 하는 순간이 되면, 해당하는 데이터의 타입을 확인한다.
그 후, 데이터타입에 따라서 숫자일 경우 8byte만큼의 메모리에 저장된 값을 읽어오고, 문자일 경우 2byte만큼의 값을 읽어온다.  
이런 과정을 통해서 값을 저장하고, 읽어오는 연산을 최적화 할 수 있게되었다.

마지막으로, 메모리에는 이진법으로 값이 저장되기 때문에 이진법 데이터를 다시 숫자, 문자, 객체, 불린값 등 최종 형태로 변환해야 한다.
그런데 똑같은 2진수라도 숫자로 해석하느냐, 문자로 해석하느냐에 따라서 결과가 달라진다,
예를들어, "0100 0001"이란 똑같은 2진수를 숫자로 해석하면 65가 되고 문자로 해석하면 "A"가 된다.

결론적으로, 데이터 타입은 아래 3가지와 같은 역할을 한다.

1. 메모리에 효율적으로 값을 저장하기 위해(값을 저장할 때 사용될 메모리 크기를 결정하기 위해)
2. 메모리에서 값을 효율적으로 읽어오기 위해(값을 읽어올 때 몇 byte만큼 읽어야 하는지 결정하기 위해)
3. 이진수를 어떻게 해석할 지 결정하기 위해

## 데이터 타입이 중요한 이유

그런데, 사실 자바스크립트는 동적타입언어로서 변수를 한번 선언하고 나면 계속 고정된 데이터타입을 유지해야 하는게 아니라
변수에 할당된 타입이 지속적으로 변화 할 수 있도록 허용한다.

```javascript
let variable = "Hello World" //variable에 문자열 타입을 할당
variable = 1234 // variable에 숫자 타입을 재할당
```

실제로 위 코드는 아무 이상없이 동작한다. 이는 자바스크립트가 변수의 타입이 바뀌는 것을 허용하면서,
거기에 따른 메모리 할당 처리를 자동적으로 해주기 때문이다.  
또한, 자바스크립트 개발자들은 메모리 반환도 신경쓸 필요가 없다.
자바스크립트 내에서 GC(Garbage Collector)가 사용되지 않은 값들을 메모리에서 주기적으로 제거해주기 때문이다.

하지만, 그렇다고 자바스크립트 개발자는 데이터 타입, 그리고 데이터 타입에 따른 메모리 할당 과정을 몰라도 된다는 것은 아니다.
알아서 메모리를 할당해주고, 반환해주는데 왜 알아야 하는걸까?  
그 이유는 개발자는 자신이 짠 코드를 책임질 수 있고, 자신이 작성한 코드가 어떻게 동작하는지 예측할 수 있어야 하기 때문이다.

구글에서 코드를 찾고 복사-붙여넣기로 프로그램을 작성했다고 해보자 지금 당장은 잘 동작할 수도 있다.
하지만 만약, 당신이 그 코드에 대한 이해없이 복붙만 했다면 그 코드로 인해 문제가 발생했을 때 해결할 수 없을 것이다.
그리고, 기획상 기능수정이 요청되었을 때 복붙만 하고 이해하지 못한 코드이기 때문에 그 코드를 원하는대로 변경할 수 없을 것이다.
위 상황은 개발자라면 누구나 한번씩 겪어보게 될 상황이다.

이와 마찬가지로, 자바스크립트 개발자라면 자바스크립트에서 메모리에 값이 어떻게 저장되는지에 대한 이해가 있어야지만
내가 짠 코드의 동작을 예측하고, 원하는 동작을 정확하게 수행시킬 수 있다.

## Primitive Type(원시 타입) vs Object Type(객체 타입)

자바스크립트에는 7가지 데이터 타입이 있다.  
각 타입에 대한 설명은[MDN-자료형](https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures)에 있기에 생략하도록 하겠다.

이 챕터에서는7가지 데이터 타입을 특정 기준에 따라서 분류하고, 각 차이점에 대해서 알아보겠다.
자바스크립트의 7가지 데이터 타입은 원시 타입과 객체 타입 두가지 분류로 나눌 수 있다.

원시 타입과 객체 타입의 차이점은 아래와 같다.

1. 원시타입은 변경불가능(immutable)하며 객체 타입은 변경가능(mutable)하다.
2. 원시 타입은 메모리에 값이 직접 저장되며, 객체 타입은 메모리에 값이 저장된 주소(참조 값)이 저장된다.
3. 따라서, 값이 복사될 시 원시 타입은 값이 복사되며, 객체 타입은 참조 값이 복사된다.

여기서의 변경가능성은 변수에 할당된 값에 대한 얘기가 아니라 값 그 자체에 대한 속성이다.
즉 변수에 담긴 값은 변수를 let으로 선언했다면 언제든지 재할당 될 수 있지만
"값" 그 자체는 원시형 타입일 경우에는 불변하다는 의미이다.

```javascript
let a = "Hello World"
a = "Bye World"
```

위 코드에서 변수에 할당된 값은 `"Hello World"`에서 `"Bye World"`로 변경되었다.
하지만 그 과정에서 `"Hello World"` 에서 "Hello"만 "Bye"로 바꾸듯이 동작한 게 아니라
`"Bye World"`라는 새로운 문자열을 만들고 변수에 할당된 값을 새롭게 만들어진 문자열로 갈아 끼운식으로 동작한다.

```javascript
let a // 1
a = "Hello World" // 2
a = "Bye World" // 3
```

동일한 코드를 동작 순서를 알아보기 위해 좀 더 세분화 하면 위와 같이 된다.
위 과정에서 일어나는 메모리상의 변화를 관찰해보면 a라는 변수가 선언되었다. 이 때 메모리상에서 특정 주소(1003)에 "a"는라는 식별자를 부여한다(1)
그리고 (2)에서는 a라는 식별자를 통해 1003 메모리에 접근하고, 메모리에 "Hello World"라는 값을 저장한다.
그리고 (3)에서는 다시 1003 메모리에 접근해서, 메모리에 저장된 "Hello World"라는 값을 "Bye World"로 **교체**한다.

즉, string은 원시 타입이고, 따라서 불변값이기 때문에 이미 만들어진 값에 일부 수정을 가하는 것이 아니라, 완전히 새로운 값을 만들어서 교체하는 식으로 동작한다.
모든 원시 값들은 위와 같은 동작을 가진다.
이로 인해 얻을 수 있는 "원시값들의 특징은 각기 다른 변수에 저장된 원시값들은 서로 영향을 미치지 못한다" 라는 특징이다.

```javascript
let a // 1
a = "Hello World" // 2
let b = a
a = "Bye World" // 3
console.log(b) // Hello World
console.log(a) // Bye World
```

b에 a에 저장된 값을 복사한 뒤에, a에 저장된 값을 변경했지만. b에 저장된 값에는 그 어떤 영향도 미치지 못하는 것을 볼 수 있다.

하지만 객체 타입은 다르게 동작한다.
객체 타입은 메모리에 값이 저장되는 것이 아니라 객체가 저장되어 있는 메모리 주소(참조값)가 저장된다.

```javascript
let a = { name: "Yeonuk" } // 1
let b = a // 2
```

위 코드의 (1) 동작에서는 특정 메모리에 a라는 식별자를 부여하고 "값으로 객체에 대한 참조"을 저장하는 동작이 일어난다.
(2)의 동작에서는 a에 저장된 참조값을 b에 그대로 복사한다.
객체를 원시값과 같이 바로 값을 저장하는게 아니라 객체를 가리키고 있는 참조값을 저장하는 이유, 그리고 객체를 변경 가능하게 설계한 이유는 효율성 때문이다.

객체는 key-value로 구성된 여러개의 property가 모여서 구성하는 값이고, 이 값들은 한계가 없이 무한히 늘어날 수도 있다.
한 객체가 10000개의 프로퍼티를 가지고 있고, 이를 다른 변수에서도 사용해야된다고 가정해보자.
이 때, 10000개만큼 모든 프로퍼티를 다 복사해서 새로운 값을 만든 뒤에 새로 만들어진 값을 다른 변수에 할당하게 된다고 하면 많은 연산이 필요하기에 비효울적이다.

그리고 10000개의 프로퍼티를 가진 객체에서 하나의 프로퍼티만 수정하면 되는 경우에도 10000개만큼의 프로퍼티를 모두 복사한 뒤
그 중 하나만 바꾸는 식으로 동작하면 당연히 비효율적이다.

그래서 자바스크립트에서는 객체를 변경가능한 값으로 설계하고, 객체를 다른 변수에 할당할 때에는 그 참조값을 전달하는 식으로 동작하도록 만들었다.
하지만 이로 인한 부작용이 있는데 그는 바로, 여러 식별자가 하나의 객체를 바라볼 수 있게 되고, 이는 곧 여러 변수가 하나의 객체를 바라보고 있을 때, 한 변수가 객체에 접근해서
객체 내부를 변경할 경우, 모두 값은 객체를 참조하고 있기에 모든 변수에서 변화가 적용된다는 점이다.

```javascript
const yeonuk = { age: 100 }
const cloneOfYeonuk = a

cloneOfYeonuk.age = "100"

const nextAgeOfYeonuk = yeonuk.age + 1 // 1001
```

즉, Yeonuk이란 변수에 객체를 할당하고, cloneOfYeonuk이라는 변수를 만들어서 거기에 Yeonuk에 할당된 객체를 그대로 전달해줬다.
그리고 나서 cloneOfYeonuk의 age를 문자열"100"으로 바꾸면 최종적으로 nextAgeOfYeonuk에서 원래 기대했던 값은
숫자 100에 + 1이 되어서 101을 기대했지만, cloneOfYeonuk에서 age를 문자열 "100"으로 수정한 것이 원본 객체에 까지 영향을 미쳐서 전혀 다른 동작이 나오게 된다.(버그 발생)

이처럼 객체타입의 변경가능성으로 인해서 개발을 할 때 객체가 어떻게 변할지 예측할 수 없다는 문제에 처하게 된다.
그래서 나오게 된 개념이 불변객체이다.

## 불변객체

불변 객체는 말그대로 변경불가능한 객체이다.
자바스크립트 자체적으로 객체는 변경가능하게 설계되었는데 어떻게 객체를 불변하게 사용할까?

객체를 불변하게 사용하려면 기존에 생성된 객체를 다른 변수에 할당하거나, 변경을 발생할 때 마다 객체의 모든 속성을 복사해서 매번 새로운 객체를 생성해주면 된다.
즉, 객체를 한번 생성한 뒤로는 원본을 건들지 않고, 변화가 필요할 때 마다 객체를 복사해서 새로운 객체를 만들어서 사용하는 것이다.

이 불변객체라는 개념이 중요하게 사용되는 이유는 위 챕터에서 알아봤듯이 객체의 프로퍼티가 변경될 경우 버그가 발생할 확률이 높기 때문에,
그리고 객체간의 비교를 원활하게 하기 위해서이기 때문이다.

객체를 저장한 변수는 해당 객체의 참조값을 담고있기때문에 객체의 내부 프로퍼티가 아무리 변해도 계속 동일한 참조값을 가지고 있다.
그래서 만약 객체를 복사한 뒤 새로운 변수에 할당하고, 그 객체의 프로퍼티를 수정한 뒤 원본 변수와 새로운 변수를 비교해보면 동일하다고 나온다(변수에 저장된 참조값은 동일하기 때문에)

```javascript
const yeonuk = { age: 100 }
const cloneOfYeonuk = a

cloneOfYeonuk.age = "100"

console.log(yeonuk === cloneOfYeonuk) // true
```

이런 특성들 때문에 객체 내부의 프로퍼티가 변경되었는지 확인하려면 객체의 모든 프로퍼티를 순회하면서 기존값과 동일한지 검사하는 연산이 필요하다.
만약 이런 상황에서 객체의 프로퍼티로 객체가 있는 경우에는 더 많은 연산이 필요하게 될 것이다.

그래서 객체를 불변하게 사용하므로서, 즉, 새로운 객체가 필요할 경우 원본의 모든 프로퍼티를 복사한 새로운 객체를 만들게 될 경우에는 동일한지 비교를 할 때 객체의 참조값만 같은지 확인하면 되므로
비교 연산이 훨씬 간편하게 된다.

다만 이 경우에는, 모든 객체를 다 복사해서 사용하게 되기 때문에 그만큼 많은 메모리를 요구로 한다는 단점이 생길 것이다.
애초에 메모리를 효율적으로 사용하기 위해서 객체를 가변하게 설계했기때문에 이를 불변하게 사용한다면 당연히 그에 따른 trade-off가 생길 수 밖에 없다.

이처럼 객체를 불변하게 사용하느냐 가변하게 사용하느냐는 각각의 상황에 맞게 선택해야 될 문제이다.  
다만 현재에는 하드웨어의 발전으로 인해서 과거보다 메모리가 넉넉해졌고, 따라서 메모리를 많이 사용하다는 것에 대한 부담이 다소 줄어들었다.  
이에 따라서 메모리 효율성을 일부 포기하더라도 안전한 프로그램을 작성하기 위해서 최근 많음 프레임워크나 라이브러리에서 불변객체라는 개념을 활용하고 있는 것으로 보인다.

### 참고자료

[코어 자바스크립트](https://books.google.co.kr/books?id=RyyZzQEACAAJ&dq=%EC%BD%94%EC%96%B4%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8&hl=ko&sa=X&redir_esc=y)  
[모던 자바스크립트 Deep dive](https://books.google.co.kr/books?id=g4fazQEACAAJ&dq=%EB%AA%A8%EB%8D%98+%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+deep+dive&hl=ko&sa=X&redir_esc=y)  
[자바스크립트 완벽 가이드](https://books.google.co.kr/books?id=CQ6LlAEACAAJ&dq=%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+%EC%99%84%EB%B2%BD+%EA%B0%80%EC%9D%B4%EB%93%9C&hl=ko&sa=X&redir_esc=y)

### 각주

[^1]: <<순서도 작성>>. 정익사. 13쪽
