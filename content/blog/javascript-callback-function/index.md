---
title: Javascript 톺아보기 4. 콜백함수
date: "2021-08-26T22:09:59.307Z"
description: "콜백함수란 무엇이고 어떤 원리로 가능한가?"
---

자바스크립트 개발자중에 콜백함수라는 단어를 한번도 안 들어보고, 안 사용해본 사람은 없을 것이다.
이 콜백함수란 개념이 어떻게 동작가능한것인지, 어떠한 장점을 가졌는지 알아보자.

## 일급객체

자바스크립트의 함수는 사실 객체이다. 엄밀히 말하면 우리가 필요할 때 호출해서 함수본문을 실행시킬 수 있는 기능을 가진 객체이다.

또한 자바스크립트의 함수는 일급객체이다.
일급객체는 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킨다.
일반적으로 적용가능한 연산이라 함은 아래 4가지와 같다.

1. 런타임에 생성할 수 있다.
2. 변수나 자료구조에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

위 4가지 조건을 간단하게 말하자면 결국 **값** 으로서 사용할 수 있다는 의미가 된다.

자바스크립트는 다중 패러다임 언어이다. 즉, 객체지향 프로그래밍과 함수형 프로그래밍을 모두 지원하는 언어이다.

그중 함수형프로그래밍의 시작은 함수를 값으로서 취급할 수 있는 것 부터 시작한다.
함수를 값으로서 취급가능하게 된다면 함수를 다른 함수의 인자로 전달하고, 함수에서 함수를 반환하는 등의 기법을 사용할 수 있게 되며 이게 곧 함수형 프로그래밍의 근간이다.

위의 줄에서 함수를 다른 함수의 인자로 전달한다라는 문장이 있었다. 여기서 다른 함수에 전달되는 함수를 **콜백함수**라고 부른다.

## 콜백함수

> A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action. [^1]

다른 함수에 인자로 전달되는 함수가 콜백함수라고 했다.
실제 콜백함수의 예시를 살펴보자.

```javascript
function repeat10(func) {
  for (let i = 0; i < 10; i++) {
    func()
  }
}

repeat10(() => console.log("Hello"))
```

위 코드에는 repeat10 함수가 있고, 함수 본문에서는 매개변수로 전달받은 함수를 10번 호출하고 있다.
이 때 실질적으로 인자로 전달된 `console.log("Hello")`를 실행하는 익명함수가 콜백함수이다.

콜백함수는 반드시 익명함수일 필요는 없다, 모든 함수가 콜백함수가 될 수 있다.

콜백함수는 결국 함수간의 합성을 의미한다.
함수의 합성이란 둘 이상의 함수를 조합해서 계산을 하거나, 새로운 함수를 만드는 것이다.
합성과정에서 다른 함수의 내부로 전달되는 함수를 콜백함수라고 하며, 함수를 전달받은 함수를 고차함수(HOF)라고 한다.

이런 합성패턴은 결국 좋은 프로그램의 가장 근본이 되는 원칙인 낮은 결합도(loose coupling)을 구현하기 위한 방법이다.

기존의 예시를 합성을 이용하지 않은 방식으로 변환해보자.

```javascript
function hello10Times() {
  for (let i = 0; i < 10; i++) {
    console.log("Hello")
  }
}

hello10Times()
```

첫번째 예시코드와 이 예시코드는 기능적으로는 완벽히 일치한다.

하지만, `hello10Times` 함수는 `console.log("Hello")` 강하게 결합되어 있다.
이런 상황에서는 함수의 재사용성이 극도로 떨어진다.

이 함수는 말 그대로 `Hello`를 10번 출력하는데 밖에 사용하지 못한다.

하지만, `repeat10` 단순히 내부에서 수행할 동작을 함수형태의 인자로 받겠다고 한 것 뿐인데 훨씬 결합도가 낮은 함수가 만들어졌고
그 결과, 낮은 결합도를 통한 재사용의 용이함을 얻었다.

이런 함수의 합성패턴에서 콜백함수의 호출시점은 고차함수가 결정한다.
인자로 함수의 호출값이 아닌 함수 자체를 넘겼으므로, 그 콜백함수를 언제 어떻게 호출할지는 고차함수가 결정하는 것이다.

예를 들어 `Array.prototype.map` 함수는 전달받은 콜백함수에 인자로 배열의 `요소, 인덱스, 배열`을 인자로 전달하며 배열의 length만큼 호출한 뒤 그 결과값을 모아 새로운 배열을 반환한다.

```javascript
const array = [1, 2, 3]

array.map(el => el * 2) // [2,4,6]
```

이 때 `Array.prototype.map`에 전달된 함수는 본인이 언제, 어디서, 몇번 호출될 것인지 인자로 무엇이 전달될 것인지 알지 못한다. 이 모든것은 고차함수인 `Array.prototype.map`에서 결정하는 것이다.

이러한 콜백함수 패턴은 비동기 처리에도 굉장히 유용하게 쓰인다.
비동기적으로 실행되는 코드가 종료된 뒤 취할 행동을 함수형태로 만들어서 전달하는 식으로 콜백함수는 유용하게 사용된다.

```javascript
setTimeout(() => {
  console.log("async end")
}, 300)
```

위의 코드는 비동기적으로 실행되는 함수인 `setTimeout`을 호출하였고, 300 millisecond가 지난 후 취할 행동을 함수의 형태로 전달했다.

함수형 자바스크립트 프로그래밍(유인동 저)에서는 위처럼 비동기 상황에서 비동기 루프가 끝난 후 다시 콜스택으로 그 결과를 돌려주는 함수만을 콜백함수라 명칭해야 된다고 주장하기도 한다.
그 이유로 인자로 전달되는 모든 함수를 콜백함수라고 부른다면 표현의 제약이 생기고 곧 이는 상상력의 제약으로 이어진다고 말한다.

함수형 프로그래밍에서는 함수의 합성을 매우 적극적으로 사용하므로, 함수들이 각기 다양한 용도로 사용될 수 있다.
이런 상황에서 모든 인자로 전달되는 함수를 콜백함수로 통칭하는 것은 표현의 제약을 만든다는 의견에 동의한다.

다만, MDN에서 콜백함수는 다른 함수에 인자로 전달되어서 호출되는 함수라고 명확희 정의하고 있고, 많은 사람들이 이 정의에 입각해서 사고를 하고 있기 때문에
콜백함수를 더 큰 개념으로 삼고, 그 콜백함수안에 소분류로 각기 함수들의 사용목적에 따라 `predicate, eventListener` 등으로 정의하는 것은 어떨까란 생각이 든다.

또한, 콜백패턴만을 이용해서 비동기를 처리한다면 콜백함수에 다시 콜백함수가 전달되면서 결국 콜백의 깊이가 깊어지고 이로인해 코드의 가독성이 나빠지는 `callback hell`의 부작용을 겪을 수 있다.
이 문제를 해결하기 위해 `Promise와 async, await` 등이 등장했는데 이에 대해서는 별도의 포스팅에서 다뤄보도록 하겠다.

### 참고자료

[코어 자바스크립트](https://books.google.co.kr/books?id=RyyZzQEACAAJ&dq=%EC%BD%94%EC%96%B4%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8&hl=ko&sa=X&redir_esc=y)  
[모던 자바스크립트 Deep dive](https://books.google.co.kr/books?id=g4fazQEACAAJ&dq=%EB%AA%A8%EB%8D%98+%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+deep+dive&hl=ko&sa=X&redir_esc=y)  
[함수형 자바스크립트 프로그래밍](https://books.google.co.kr/books?id=pQeaswEACAAJ&dq=%ED%95%A8%EC%88%98%EC%9D%98+%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D&hl=ko&sa=X&ved=2ahUKEwj98sT588_yAhUlBKYKHcKNAi4Q6AEwAXoECAoQAQ)

### 각주

[^1]: MDN-Callback function. [URL](https://developer.mozilla.org/en-US/docs/Glossary/Callback_function)
